#!/usr/bin/env python3
"""
xylomorphic_blender_gen.py
--------------------------
Generate Blender Python scripts for Xylomorphic Architecture scenes (no animations),
then (optionally) run Blender headless to emit .blend files and still PNG renders.

Examples:
  # Generate scripts only
  python xylomorphic_blender_gen.py --outdir out --scenes all

  # Generate and run Blender headless (still images)
  python xylomorphic_blender_gen.py --outdir out --scenes cellulose_spires,pulp_conduits --render

  # Use Cycles with 64 samples and custom resolution
  python xylomorphic_blender_gen.py --outdir out --scenes all --render --engine CYCLES --samples 64 --res 1920x1080
"""

import argparse, os, pathlib, subprocess, sys
from datetime import datetime
from textwrap import dedent

SCENE_CHOICES = [
    "cellulose_spires",
    "pulp_conduits",
    "bioroof_canopy",
    "forest_core",
    "xylomorphic_cityscape",
]

def parse_resolution(res_str):
    try:
        w, h = map(int, res_str.lower().split("x"))
        return w, h
    except Exception:
        raise argparse.ArgumentTypeError("Resolution must look like 1920x1080")

def mkdir(p): p.mkdir(parents=True, exist_ok=True); return p
def write_file(p, txt): mkdir(p.parent); p.write_text(txt, encoding="utf-8"); return p

# --- Common script header ---
HEADER = """\
# AUTOGENERATED by xylomorphic_blender_gen.py
import bpy, math, mathutils, random
from math import sin, cos, pi

# Clean slate
bpy.ops.wm.read_factory_settings(use_empty=True)
scene = bpy.context.scene
scene.frame_start = 1
scene.frame_end = 1

# Color management: keep bright in headless
try:
    scene.display_settings.display_device = 'sRGB'
    scene.view_settings.view_transform = 'Standard'
except Exception:
    pass
"""

ENGINE = """\
# Render engine & resolution
scene.render.engine = "{engine}"
scene.render.resolution_x = {rx}
scene.render.resolution_y = {ry}
scene.render.resolution_percentage = 100

# PNG output (explicit)
scene.render.image_settings.file_format = 'PNG'
scene.render.image_settings.color_mode = 'RGB'
scene.render.image_settings.color_depth = '8'
scene.render.image_settings.compression = 15

if scene.render.engine == "CYCLES":
    scene.cycles.samples = {samples}
    # Prefer GPU if present (safe attempt)
    try:
        prefs = bpy.context.preferences.addons["cycles"].preferences
        # set device type if possible; ignore if not available headless
        if hasattr(prefs, "get_device_types"):
            types = prefs.get_device_types(bpy.context)
            if "CUDA" in types: prefs.compute_device_type = "CUDA"
            elif "OPTIX" in types: prefs.compute_device_type = "OPTIX"
            elif "HIP" in types: prefs.compute_device_type = "HIP"
        scene.cycles.device = "GPU"
    except Exception:
        pass
else:
    # EEVEE visibility boosts
    scene.eevee.taa_render_samples = max(16, {samples})
    scene.eevee.use_gtao = True
    scene.eevee.use_bloom = True
"""

WORLD_LIGHT_CAM = """\
# World light
if not scene.world:
    scene.world = bpy.data.worlds.new("World")
scene.world.use_nodes = True
wn = scene.world.node_tree
bg = wn.nodes.get("Background")
if bg:
    bg.inputs[0].default_value = (0.025, 0.035, 0.02, 1.0)  # dim greenish
    bg.inputs[1].default_value = 1.6  # brightness

# Sunlight (key)
sun_data = bpy.data.lights.new("Sun","SUN")
sun_data.energy = 4.0
sun = bpy.data.objects.new("Sun", sun_data)
bpy.context.collection.objects.link(sun)
sun.location = (8,-8,10)
sun.rotation_euler = (math.radians(60), 0, math.radians(35))

# Camera
cam_data = bpy.data.cameras.new("Camera")
cam = bpy.data.objects.new("Camera", cam_data)
bpy.context.collection.objects.link(cam)
scene.camera = cam
cam.location = (10, -12, 8)
cam.rotation_euler = (math.radians(55), 0, math.radians(40))

# Activate camera for this view layer
if bpy.context.view_layer.objects.active is None:
    bpy.context.view_layer.objects.active = cam
scene.camera = cam
bpy.context.view_layer.update()
"""

MATERIALS = """\
# Materials
def mat_emissive(name,col=(1,1,1,1),strength=5):
    m=bpy.data.materials.new(name); m.use_nodes=True
    nt=m.node_tree
    for n in list(nt.nodes): nt.nodes.remove(n)
    e=nt.nodes.new("ShaderNodeEmission"); e.inputs[0].default_value=col; e.inputs[1].default_value=strength
    o=nt.nodes.new("ShaderNodeOutputMaterial"); nt.links.new(e.outputs[0],o.inputs[0])
    return m

def mat_pbr(name,base=(.5,.5,.5,1),rough=.6,metal=.0):
    m=bpy.data.materials.new(name); m.use_nodes=True
    p=m.node_tree.nodes.get("Principled BSDF")
    if not p:
        p = m.node_tree.nodes.new("ShaderNodeBsdfPrincipled")
        out = m.node_tree.nodes.get("Material Output") or m.node_tree.nodes.new("ShaderNodeOutputMaterial")
        m.node_tree.links.new(p.outputs["BSDF"], out.inputs["Surface"])
    p.inputs["Base Color"].default_value=base
    p.inputs["Roughness"].default_value=rough
    p.inputs["Metallic"].default_value=metal
    return m

def add_diffuse_fill(name="Fill", energy=800, size=24, loc=(0,0,14)):
    L = bpy.data.lights.new(name,"AREA")
    L.energy = energy
    o = bpy.data.objects.new(name,L)
    bpy.context.collection.objects.link(o)
    o.location = loc
    o.scale = (size, size, 1)
    return o
"""

CELLULOSE_SPIRES = """\
# Scene: Cellulose Spires
wood = mat_pbr("Wood",(0.35,0.2,0.1,1),0.7,0)
glow = mat_emissive("Phloem",(0.4,0.8,0.6,1),10)
random.seed(1)
for i in range(40):
    r = random.uniform(0.3,1.0)
    h = random.uniform(3,9)
    x = random.uniform(-8,8)
    y = random.uniform(-8,8)
    bpy.ops.mesh.primitive_cylinder_add(radius=r, depth=h, location=(x,y,h/2))
    c=bpy.context.active_object
    c.data.materials.append(wood)
    if random.random()<0.2:
        bpy.ops.mesh.primitive_torus_add(major_radius=r+0.2,minor_radius=0.05,location=(x,y,h*0.6))
        t=bpy.context.active_object; t.data.materials.append(glow)
bpy.ops.mesh.primitive_plane_add(size=40,location=(0,0,0))
p=bpy.context.active_object; p.data.materials.append(mat_pbr("Ground",(0.1,0.1,0.08,1),0.9,0))

# Diffuse fill + camera
add_diffuse_fill(energy=900, size=26, loc=(0,0,16))
scene.camera.location = (12, -12, 8)
scene.camera.rotation_euler = (math.radians(58), 0, math.radians(42))
bpy.context.view_layer.objects.active = scene.camera
bpy.context.view_layer.update()
"""

PULP_CONDUITS = """\
# Scene: Pulp Conduits
fiber = mat_pbr("Fiber",(0.75,0.7,0.6,1),0.4,0)
lumen = mat_emissive("Lumen",(0.9,0.5,0.3,1),8)
for i in range(30):
    pts=[(random.uniform(-5,5),random.uniform(-5,5),z) for z in [0,1,2,3,4]]
    cu=bpy.data.curves.new("Conduit","CURVE"); cu.dimensions='3D'
    s=cu.splines.new('POLY'); s.points.add(len(pts)-1)
    for j,p in enumerate(pts): s.points[j].co=(*p,1)
    cu.bevel_depth=0.08; cu.bevel_resolution=3
    ob=bpy.data.objects.new("ConduitObj",cu)
    bpy.context.collection.objects.link(ob)
    ob.data.materials.append(fiber if i%2 else lumen)
bpy.ops.mesh.primitive_plane_add(size=20,location=(0,0,-0.2))
b=bpy.context.active_object; b.data.materials.append(mat_pbr("Base",(0.08,0.1,0.09,1),0.9,0))

scene.camera.location = (10, -14, 9)
scene.camera.rotation_euler = (math.radians(60), 0, math.radians(40))
bpy.context.view_layer.objects.active = scene.camera
bpy.context.view_layer.update()
"""

BIOROOF_CANOPY = """\
# Scene: BioRoof Canopy
leaf = mat_pbr("Leaf",(0.1,0.4,0.1,1),0.5,0)
node = mat_emissive("Node",(0.2,0.8,0.6,1),15)
for i in range(-8,9,2):
    for j in range(-8,9,2):
        z = 3+0.8*sin(i*0.5)*cos(j*0.5)
        bpy.ops.mesh.primitive_plane_add(size=1.8,location=(i,j,z))
        o=bpy.context.active_object; o.rotation_euler=(math.radians(25*sin(i+j)),0,math.radians(15*cos(i-j)))
        o.data.materials.append(leaf)
        if random.random()<0.3:
            bpy.ops.mesh.primitive_uv_sphere_add(radius=0.1,location=(i,j,z+0.5))
            s=bpy.context.active_object; s.data.materials.append(node)
bpy.ops.mesh.primitive_plane_add(size=25,location=(0,0,0))
g=bpy.context.active_object; g.data.materials.append(mat_pbr("Floor",(0.07,0.08,0.09,1),0.8,0))

scene.camera.location = (14, -18, 12)
scene.camera.rotation_euler = (math.radians(64), 0, math.radians(50))
bpy.context.view_layer.objects.active = scene.camera
bpy.context.view_layer.update()
"""

FOREST_CORE = """\
# Scene: Forest Core (bioluminescent atrium)
bark = mat_pbr("Bark",(0.25,0.15,0.1,1),0.8,0)
sap  = mat_emissive("Sap",(1.0,0.6,0.2,1),20)
for i in range(50):
    theta=random.uniform(0,2*pi)
    r=random.uniform(1.5,7)
    h=random.uniform(3,10)
    x=r*cos(theta); y=r*sin(theta)
    bpy.ops.mesh.primitive_cylinder_add(radius=0.2+0.05*sin(i),depth=h,location=(x,y,h/2))
    c=bpy.context.active_object; c.data.materials.append(bark)
    if random.random()<0.15:
        bpy.ops.mesh.primitive_uv_sphere_add(radius=0.2,location=(x,y,h))
        s=bpy.context.active_object; s.data.materials.append(sap)
bpy.ops.mesh.primitive_plane_add(size=30,location=(0,0,0))
p=bpy.context.active_object; p.data.materials.append(mat_pbr("Soil",(0.08,0.07,0.06,1),0.9,0))

scene.camera.location = (13, -17, 11)
scene.camera.rotation_euler = (math.radians(62), 0, math.radians(48))
bpy.context.view_layer.objects.active = scene.camera
bpy.context.view_layer.update()
"""

XYLOMORPHIC_CITYSCAPE = """\
# Scene: Xylomorphic Cityscape
# A panoramic bio-architectural skyline where cellulose towers merge with luminous vascular roots.

wood_tower = mat_pbr("TowerWood",(0.28,0.18,0.12,1),0.7,0)
glass_sap  = mat_emissive("GlassSap",(0.6,0.9,0.8,1),20)
root_mat   = mat_pbr("Root",(0.12,0.08,0.06,1),0.8,0)
mist_mat   = mat_emissive("Mist",(0.6,0.7,0.9,1),1.5)

random.seed(2025)
for i in range(14):
    x = random.uniform(-10,10)
    y = random.uniform(-10,10)
    h = random.uniform(6,18)
    r = random.uniform(0.5,1.0)
    bpy.ops.mesh.primitive_cylinder_add(radius=r, depth=h, location=(x,y,h/2))
    t=bpy.context.active_object
    t.data.materials.append(wood_tower)
    # luminous cap
    bpy.ops.mesh.primitive_uv_sphere_add(radius=r*0.6, location=(x,y,h+0.5))
    s=bpy.context.active_object; s.data.materials.append(glass_sap)
    # vascular roots branching
    for j in range(random.randint(2,5)):
        a = random.uniform(0,2*pi)
        l = random.uniform(2,5)
        x2=x+l*cos(a); y2=y+l*sin(a)
        bpy.ops.curve.primitive_bezier_curve_add()
        c=bpy.context.active_object
        bp=c.data.splines[0].bezier_points
        bp[0].co=(x,y,0); bp[1].co=(x2,y2,-2)
        c.data.bevel_depth=0.05; c.data.bevel_resolution=3
        c.data.materials.append(root_mat)

# Ground / water reflection plane
bpy.ops.mesh.primitive_plane_add(size=60,location=(0,0,0))
g=bpy.context.active_object; g.data.materials.append(mat_pbr("Ground",(0.05,0.06,0.07,1),0.9,0))

# Floating "mist" layers (emissive, visible)
for k in range(3):
    z = 2.5 + k*3.5
    bpy.ops.mesh.primitive_plane_add(size=60,location=(0,0,z))
    m=bpy.context.active_object
    m.data.materials.append(mist_mat)

# Camera setup for panorama
scene.camera.location = (22, -22, 14)
scene.camera.rotation_euler = (math.radians(65), 0, math.radians(45))
bpy.context.view_layer.objects.active = scene.camera
bpy.context.view_layer.update()
"""

FOOTER = """\
# Save & render
blend=r"{blend}"; png=r"{png}"
import os
os.makedirs(os.path.dirname(blend), exist_ok=True)
os.makedirs(os.path.dirname(png), exist_ok=True)

# Ensure frame & output
scene.frame_set(1)
scene.render.filepath = png

# Color management (keep bright in headless)
try:
    scene.display_settings.display_device = 'sRGB'
    scene.view_settings.view_transform = 'Standard'
    scene.view_settings.look = 'None'
except Exception:
    pass

# Final safety: make sure we have a camera
if scene.camera is None:
    cam_data = bpy.data.cameras.new("Camera")
    cam = bpy.data.objects.new("Camera", cam_data)
    bpy.context.collection.objects.link(cam)
    scene.camera = cam
    cam.location = (10, -10, 8)
    cam.rotation_euler = (math.radians(60), 0, math.radians(45))

# Update depsgraph; do NOT assign bpy.context.view_layer (read-only in headless)
bpy.context.view_layer.objects.active = scene.camera
bpy.context.view_layer.update()
_ = bpy.context.evaluated_depsgraph_get()

# Render still
bpy.ops.render.render(write_still=True)

# Save .blend
bpy.ops.wm.save_mainfile(filepath=blend)
"""



def scene_code(name,engine,res,samples,blend,png):
    sections=[
        HEADER,
        ENGINE.format(engine=engine,rx=res[0],ry=res[1],samples=samples),
        WORLD_LIGHT_CAM,
        MATERIALS
    ]
    if name=="cellulose_spires": sections.append(CELLULOSE_SPIRES)
    elif name=="pulp_conduits": sections.append(PULP_CONDUITS)
    elif name=="bioroof_canopy": sections.append(BIOROOF_CANOPY)
    elif name=="forest_core": sections.append(FOREST_CORE)
    elif name=="xylomorphic_cityscape": sections.append(XYLOMORPHIC_CITYSCAPE)
    else:
        raise ValueError(f"Unknown scene {name}")
    sections.append(FOOTER.format(blend=blend,png=png))
    return dedent("\n".join(sections))

def main():
    ap=argparse.ArgumentParser()
    ap.add_argument("--outdir",required=True)
    ap.add_argument("--scenes",default="all")
    ap.add_argument("--render",action="store_true")
    ap.add_argument("--blender",default="blender")
    ap.add_argument("--engine",default="CYCLES", choices=["CYCLES","BLENDER_EEVEE"])
    ap.add_argument("--samples",type=int,default=64)
    ap.add_argument("--res",type=parse_resolution,default="1280x720")
    args=ap.parse_args()

    out=pathlib.Path(args.outdir)
    scripts=mkdir(out/"scripts"); blends=mkdir(out/"blends"); renders=mkdir(out/"renders")
    timestamp=datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")

    scenes = SCENE_CHOICES if args.scenes.strip().lower()=="all" else [s.strip() for s in args.scenes.split(",")]

    built=[]
    for s in scenes:
        base=f"{s}-{timestamp}"
        scp=scripts/f"{base}.py"; bl=blends/f"{base}.blend"; pn=renders/f"{base}.png"
        txt=scene_code(s,args.engine,args.res,args.samples,str(bl),str(pn))
        write_file(scp,txt)
        print(f"[OK] wrote {scp}")
        built.append((s,scp))
        if args.render:
            cmd=[args.blender,"-b","-noaudio","--python",str(scp)]
            print("[RUN]"," ".join(cmd))
            subprocess.run(cmd,check=True)
    print("[DONE] All scenes generated.")

if __name__=="__main__":
    main()
