# AUTOGENERATED by xylomorphic_blender_gen.py
import bpy, math, mathutils, random
from math import sin, cos, pi

# Clean slate
bpy.ops.wm.read_factory_settings(use_empty=True)
scene = bpy.context.scene
scene.frame_start = 1
scene.frame_end = 1

# Color management: keep bright in headless
try:
    scene.display_settings.display_device = 'sRGB'
    scene.view_settings.view_transform = 'Standard'
except Exception:
    pass

# Render engine & resolution
scene.render.engine = "CYCLES"
scene.render.resolution_x = 400
scene.render.resolution_y = 200
scene.render.resolution_percentage = 100

# PNG output (explicit)
scene.render.image_settings.file_format = 'PNG'
scene.render.image_settings.color_mode = 'RGB'
scene.render.image_settings.color_depth = '8'
scene.render.image_settings.compression = 15

if scene.render.engine == "CYCLES":
    scene.cycles.samples = 32
    # Prefer GPU if present (safe attempt)
    try:
        prefs = bpy.context.preferences.addons["cycles"].preferences
        # set device type if possible; ignore if not available headless
        if hasattr(prefs, "get_device_types"):
            types = prefs.get_device_types(bpy.context)
            if "CUDA" in types: prefs.compute_device_type = "CUDA"
            elif "OPTIX" in types: prefs.compute_device_type = "OPTIX"
            elif "HIP" in types: prefs.compute_device_type = "HIP"
        scene.cycles.device = "GPU"
    except Exception:
        pass
else:
    # EEVEE visibility boosts
    scene.eevee.taa_render_samples = max(16, 32)
    scene.eevee.use_gtao = True
    scene.eevee.use_bloom = True

# World light
if not scene.world:
    scene.world = bpy.data.worlds.new("World")
scene.world.use_nodes = True
wn = scene.world.node_tree
bg = wn.nodes.get("Background")
if bg:
    bg.inputs[0].default_value = (0.025, 0.035, 0.02, 1.0)  # dim greenish
    bg.inputs[1].default_value = 1.6  # brightness

# Sunlight (key)
sun_data = bpy.data.lights.new("Sun","SUN")
sun_data.energy = 4.0
sun = bpy.data.objects.new("Sun", sun_data)
bpy.context.collection.objects.link(sun)
sun.location = (8,-8,10)
sun.rotation_euler = (math.radians(60), 0, math.radians(35))

# Camera
cam_data = bpy.data.cameras.new("Camera")
cam = bpy.data.objects.new("Camera", cam_data)
bpy.context.collection.objects.link(cam)
scene.camera = cam
cam.location = (10, -12, 8)
cam.rotation_euler = (math.radians(55), 0, math.radians(40))

# Activate camera for this view layer
if bpy.context.view_layer.objects.active is None:
    bpy.context.view_layer.objects.active = cam
scene.camera = cam
bpy.context.view_layer.update()

# Materials
def mat_emissive(name,col=(1,1,1,1),strength=5):
    m=bpy.data.materials.new(name); m.use_nodes=True
    nt=m.node_tree
    for n in list(nt.nodes): nt.nodes.remove(n)
    e=nt.nodes.new("ShaderNodeEmission"); e.inputs[0].default_value=col; e.inputs[1].default_value=strength
    o=nt.nodes.new("ShaderNodeOutputMaterial"); nt.links.new(e.outputs[0],o.inputs[0])
    return m

def mat_pbr(name,base=(.5,.5,.5,1),rough=.6,metal=.0):
    m=bpy.data.materials.new(name); m.use_nodes=True
    p=m.node_tree.nodes.get("Principled BSDF")
    if not p:
        p = m.node_tree.nodes.new("ShaderNodeBsdfPrincipled")
        out = m.node_tree.nodes.get("Material Output") or m.node_tree.nodes.new("ShaderNodeOutputMaterial")
        m.node_tree.links.new(p.outputs["BSDF"], out.inputs["Surface"])
    p.inputs["Base Color"].default_value=base
    p.inputs["Roughness"].default_value=rough
    p.inputs["Metallic"].default_value=metal
    return m

def add_diffuse_fill(name="Fill", energy=800, size=24, loc=(0,0,14)):
    L = bpy.data.lights.new(name,"AREA")
    L.energy = energy
    o = bpy.data.objects.new(name,L)
    bpy.context.collection.objects.link(o)
    o.location = loc
    o.scale = (size, size, 1)
    return o

# Scene: Cellulose Spires
wood = mat_pbr("Wood",(0.35,0.2,0.1,1),0.7,0)
glow = mat_emissive("Phloem",(0.4,0.8,0.6,1),10)
random.seed(1)
for i in range(40):
    r = random.uniform(0.3,1.0)
    h = random.uniform(3,9)
    x = random.uniform(-8,8)
    y = random.uniform(-8,8)
    bpy.ops.mesh.primitive_cylinder_add(radius=r, depth=h, location=(x,y,h/2))
    c=bpy.context.active_object
    c.data.materials.append(wood)
    if random.random()<0.2:
        bpy.ops.mesh.primitive_torus_add(major_radius=r+0.2,minor_radius=0.05,location=(x,y,h*0.6))
        t=bpy.context.active_object; t.data.materials.append(glow)
bpy.ops.mesh.primitive_plane_add(size=40,location=(0,0,0))
p=bpy.context.active_object; p.data.materials.append(mat_pbr("Ground",(0.1,0.1,0.08,1),0.9,0))

# Ensure camera is active and sane
scene.camera.location = (12, -12, 8)
scene.camera.rotation_euler = (math.radians(58), 0, math.radians(42))
bpy.context.view_layer.objects.active = scene.camera
bpy.context.view_layer.update()

# Save & render
blend=r"out_xylomorphic/blends/cellulose_spires-20251103T175145Z.blend"; png=r"out_xylomorphic/renders/cellulose_spires-20251103T175145Z.png"
import os
os.makedirs(os.path.dirname(blend),exist_ok=True)
os.makedirs(os.path.dirname(png),exist_ok=True)

# Ensure frame & filepath set
scene.frame_set(1)
scene.render.filepath = png

# Final safety: camera & layer update
bpy.context.view_layer.objects.active = scene.camera
bpy.context.scene.camera = scene.camera
bpy.context.view_layer.update()

# ---------- Explicit Render Settings ----------
scene.display_settings.display_device = 'sRGB'
scene.render.image_settings.file_format = 'PNG'
scene.render.image_settings.color_mode = 'RGB'
scene.render.image_settings.color_depth = '8'
scene.render.image_settings.compression = 15

# Set view transform to Standard (headless Filmic is dark)
try:
    scene.view_settings.view_transform = 'Standard'
except Exception:
    pass

# Make sure the active view layer exists
bpy.context.window.scene = scene
bpy.context.view_layer = scene.view_layers[0]
bpy.context.view_layer.update()

# Ensure camera is active and visible
bpy.context.scene.camera = scene.camera
bpy.context.view_layer.objects.active = scene.camera
bpy.context.scene.camera.data.type = 'PERSP'

# Warm up dependency graph
bpy.context.evaluated_depsgraph_get().update()

# ---------- Render Still ----------
scene.render.filepath = png
bpy.ops.render.render(write_still=True)

# ---------- Save Blend ----------
bpy.ops.wm.save_mainfile(filepath=blend)

