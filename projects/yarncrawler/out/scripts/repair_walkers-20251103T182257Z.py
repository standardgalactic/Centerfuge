
# AUTOGENERATED by yarncrawler_blender_gen.py
import bpy, math, mathutils, random
bpy.ops.wm.read_factory_settings(use_empty=True)
if not bpy.context.scene: bpy.ops.scene.new(type='NEW')
scene = bpy.context.scene
scene.frame_start = 1
scene.frame_end = 1


engine = "CYCLES"
scene.render.engine = engine
scene.render.resolution_x = 1280
scene.render.resolution_y = 720
scene.render.resolution_percentage = 100
if engine == "CYCLES":
    try:
        bpy.context.scene.cycles.samples = 64
        bpy.context.preferences.addons["cycles"].preferences.compute_device_type = "CUDA"
        bpy.context.scene.cycles.device = "GPU"
    except Exception:
        pass


import math
if scene.world is None:
    scene.world = bpy.data.worlds.new("World")
scene.world.use_nodes = True
wn = scene.world.node_tree
bg = wn.nodes.get("Background")
if bg:
    bg.inputs[0].default_value = (0.015,0.015,0.02,1.0)
    bg.inputs[1].default_value = 1.0
light_data = bpy.data.lights.new(name="KeyLight", type='AREA')
light_data.energy = 3000
light_data.shape = 'RECTANGLE'
light_data.size = 6.0
light_data.size_y = 3.0
light_object = bpy.data.objects.new(name="KeyLight", object_data=light_data)
scene.collection.objects.link(light_object)
light_object.location = (6,-6,6)
light_object.rotation_euler = (math.radians(50),0,math.radians(35))
fill_data = bpy.data.lights.new(name="Fill", type='POINT')
fill_data.energy = 800
fill_obj = bpy.data.objects.new(name="Fill", object_data=fill_data)
scene.collection.objects.link(fill_obj)
fill_obj.location = (-4,2,2)
cam_data = bpy.data.cameras.new("Camera")
cam_obj = bpy.data.objects.new("Camera", cam_data)
scene.collection.objects.link(cam_obj)
scene.camera = cam_obj
cam_obj.location = (10,-10,8)
cam_obj.rotation_euler = (math.radians(55),0,math.radians(45))
cam_data.lens = 45


def make_emissive(name, color=(1,1,1,1), strength=5.0):
    mat = bpy.data.materials.new(name)
    mat.use_nodes = True
    nt = mat.node_tree
    for n in list(nt.nodes):
        nt.nodes.remove(n)
    out = nt.nodes.new("ShaderNodeOutputMaterial")
    emi = nt.nodes.new("ShaderNodeEmission")
    emi.inputs["Color"].default_value = color
    emi.inputs["Strength"].default_value = strength
    nt.links.new(emi.outputs["Emission"], out.inputs["Surface"])
    return mat
def make_principled(name, base=(0.8,0.8,0.8,1), rough=0.5, metallic=0.0):
    mat = bpy.data.materials.new(name)
    mat.use_nodes = True
    bsdf = mat.node_tree.nodes.get("Principled BSDF")
    bsdf.inputs["Base Color"].default_value = base
    bsdf.inputs["Roughness"].default_value = rough
    bsdf.inputs["Metallic"].default_value = metallic
    return mat


steel = make_principled("Steel", base=(0.7,0.72,0.75,1), rough=0.2, metallic=0.9)
rubber = make_principled("Rubber", base=(0.02,0.02,0.02,1), rough=0.8, metallic=0.0)
glow   = make_emissive("Beacon", color=(0.9,0.5,0.1,1), strength=20.0)
for i in range(-6, 7):
    for j in range(-6, 7):
        sx = 0.8 + 0.1*((i+j)&1)
        sy = 0.8 + 0.1*(((i*7)+j)&1)
        bpy.ops.mesh.primitive_cube_add(size=1, location=(i*1.05, j*1.05, -0.5))
        t = bpy.context.active_object
        t.scale = (sx, sy, 0.03)
        t.data.materials.append(make_principled("Patch", base=(0.15+0.05*(i&1),0.16,0.17,1), rough=0.7))
def add_walker(pos=(0,0,0)):
    for dx in (-0.6, 0.6):
        bpy.ops.mesh.primitive_cylinder_add(radius=0.06, depth=3.0, location=(pos[0]+dx, pos[1], pos[2]+1.0))
        s = bpy.context.active_object
        s.data.materials.append(steel)
        bpy.ops.mesh.primitive_cylinder_add(radius=0.18, depth=0.1, location=(pos[0]+dx, pos[1], pos[2]-0.5))
        f = bpy.context.active_object
        f.data.materials.append(rubber)
    bpy.ops.mesh.primitive_cube_add(size=1.6, location=(pos[0], pos[1], pos[2]+2.1))
    b = bpy.context.active_object
    b.scale = (1.2, 0.8, 0.6); b.data.materials.append(steel)
    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.15, location=(pos[0], pos[1], pos[2]+3.0))
    be = bpy.context.active_object; be.data.materials.append(glow)
for k in range(6):
    add_walker(pos=(-4.0 + 1.6*k, -2.0 + 0.6*((k&1)-0.5), 0))
scene.camera.location = (8, -12, 9)
scene.camera.rotation_euler = (math.radians(65), 0, math.radians(50))


blend_path = r"out/blends/repair_walkers-20251103T182257Z.blend"
png_path   = r"out/renders/repair_walkers-20251103T182257Z.png"
import os
os.makedirs(os.path.dirname(blend_path), exist_ok=True)
os.makedirs(os.path.dirname(png_path), exist_ok=True)
scene.frame_set(1)
scene.render.filepath = png_path
bpy.ops.render.render(write_still=True)
bpy.ops.wm.save_mainfile(filepath=blend_path)
