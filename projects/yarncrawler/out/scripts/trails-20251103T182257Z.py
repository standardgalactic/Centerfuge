
# AUTOGENERATED by yarncrawler_blender_gen.py
import bpy, math, mathutils, random
bpy.ops.wm.read_factory_settings(use_empty=True)
if not bpy.context.scene: bpy.ops.scene.new(type='NEW')
scene = bpy.context.scene
scene.frame_start = 1
scene.frame_end = 1


engine = "CYCLES"
scene.render.engine = engine
scene.render.resolution_x = 1280
scene.render.resolution_y = 720
scene.render.resolution_percentage = 100
if engine == "CYCLES":
    try:
        bpy.context.scene.cycles.samples = 64
        bpy.context.preferences.addons["cycles"].preferences.compute_device_type = "CUDA"
        bpy.context.scene.cycles.device = "GPU"
    except Exception:
        pass


import math
if scene.world is None:
    scene.world = bpy.data.worlds.new("World")
scene.world.use_nodes = True
wn = scene.world.node_tree
bg = wn.nodes.get("Background")
if bg:
    bg.inputs[0].default_value = (0.015,0.015,0.02,1.0)
    bg.inputs[1].default_value = 1.0
light_data = bpy.data.lights.new(name="KeyLight", type='AREA')
light_data.energy = 3000
light_data.shape = 'RECTANGLE'
light_data.size = 6.0
light_data.size_y = 3.0
light_object = bpy.data.objects.new(name="KeyLight", object_data=light_data)
scene.collection.objects.link(light_object)
light_object.location = (6,-6,6)
light_object.rotation_euler = (math.radians(50),0,math.radians(35))
fill_data = bpy.data.lights.new(name="Fill", type='POINT')
fill_data.energy = 800
fill_obj = bpy.data.objects.new(name="Fill", object_data=fill_data)
scene.collection.objects.link(fill_obj)
fill_obj.location = (-4,2,2)
cam_data = bpy.data.cameras.new("Camera")
cam_obj = bpy.data.objects.new("Camera", cam_data)
scene.collection.objects.link(cam_obj)
scene.camera = cam_obj
cam_obj.location = (10,-10,8)
cam_obj.rotation_euler = (math.radians(55),0,math.radians(45))
cam_data.lens = 45


def make_emissive(name, color=(1,1,1,1), strength=5.0):
    mat = bpy.data.materials.new(name)
    mat.use_nodes = True
    nt = mat.node_tree
    for n in list(nt.nodes):
        nt.nodes.remove(n)
    out = nt.nodes.new("ShaderNodeOutputMaterial")
    emi = nt.nodes.new("ShaderNodeEmission")
    emi.inputs["Color"].default_value = color
    emi.inputs["Strength"].default_value = strength
    nt.links.new(emi.outputs["Emission"], out.inputs["Surface"])
    return mat
def make_principled(name, base=(0.8,0.8,0.8,1), rough=0.5, metallic=0.0):
    mat = bpy.data.materials.new(name)
    mat.use_nodes = True
    bsdf = mat.node_tree.nodes.get("Principled BSDF")
    bsdf.inputs["Base Color"].default_value = base
    bsdf.inputs["Roughness"].default_value = rough
    bsdf.inputs["Metallic"].default_value = metallic
    return mat


import random, math
random.seed(42)
trail_mat = make_principled("Trail", base=(0.05,0.8,0.7,1), rough=0.35, metallic=0.05)
node_mat  = make_emissive("Node", color=(0.9,0.15,0.2,1), strength=10.0)
def add_polycurve(points, radius=0.03, mat=None):
    cu = bpy.data.curves.new("TrailCurve", 'CURVE')
    cu.dimensions = '3D'
    spline = cu.splines.new('POLY')
    spline.points.add(len(points)-1)
    for i, p in enumerate(points):
        spline.points[i].co = (*p, 1.0)
    cu.bevel_depth = radius
    cu.use_fill_caps = True
    ob = bpy.data.objects.new("TrailObj", cu)
    bpy.context.collection.objects.link(ob)
    if mat: ob.data.materials.append(mat)
    return ob
for k in range(22):
    p = mathutils.Vector((random.uniform(-4,4), random.uniform(-4,4), random.uniform(-0.2,0.2)))
    pts = [tuple(p)]
    direction = mathutils.Vector((random.uniform(-1,1), random.uniform(-1,1), random.uniform(-0.2,0.2))).normalized()
    length = random.randint(40, 90)
    for i in range(length):
        step = (direction + 0.35*mathutils.Vector((random.uniform(-1,1), random.uniform(-1,1), random.uniform(-0.15,0.15)))).normalized()
        p = p + 0.2*step
        p.z = max(-0.1, min(2.5, p.z))
        pts.append((p.x, p.y, p.z))
    add_polycurve(pts, radius=0.025, mat=trail_mat)
for i in range(36):
    x, y = random.uniform(-4.5,4.5), random.uniform(-4.5,4.5)
    z = random.uniform(0.0, 0.6)
    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.06, enter_editmode=False, location=(x,y,z))
    o = bpy.context.active_object
    o.data.materials.append(node_mat)
bpy.ops.mesh.primitive_plane_add(size=20, location=(0,0,-0.12))
g = bpy.context.active_object
g.data.materials.append(make_principled("Ground", base=(0.04,0.04,0.05,1), rough=0.9, metallic=0.0))


blend_path = r"out/blends/trails-20251103T182257Z.blend"
png_path   = r"out/renders/trails-20251103T182257Z.png"
import os
os.makedirs(os.path.dirname(blend_path), exist_ok=True)
os.makedirs(os.path.dirname(png_path), exist_ok=True)
scene.frame_set(1)
scene.render.filepath = png_path
bpy.ops.render.render(write_still=True)
bpy.ops.wm.save_mainfile(filepath=blend_path)
