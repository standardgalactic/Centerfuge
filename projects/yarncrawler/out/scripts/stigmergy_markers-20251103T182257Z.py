
# AUTOGENERATED by yarncrawler_blender_gen.py
import bpy, math, mathutils, random
bpy.ops.wm.read_factory_settings(use_empty=True)
if not bpy.context.scene: bpy.ops.scene.new(type='NEW')
scene = bpy.context.scene
scene.frame_start = 1
scene.frame_end = 1


engine = "CYCLES"
scene.render.engine = engine
scene.render.resolution_x = 1280
scene.render.resolution_y = 720
scene.render.resolution_percentage = 100
if engine == "CYCLES":
    try:
        bpy.context.scene.cycles.samples = 64
        bpy.context.preferences.addons["cycles"].preferences.compute_device_type = "CUDA"
        bpy.context.scene.cycles.device = "GPU"
    except Exception:
        pass


import math
if scene.world is None:
    scene.world = bpy.data.worlds.new("World")
scene.world.use_nodes = True
wn = scene.world.node_tree
bg = wn.nodes.get("Background")
if bg:
    bg.inputs[0].default_value = (0.015,0.015,0.02,1.0)
    bg.inputs[1].default_value = 1.0
light_data = bpy.data.lights.new(name="KeyLight", type='AREA')
light_data.energy = 3000
light_data.shape = 'RECTANGLE'
light_data.size = 6.0
light_data.size_y = 3.0
light_object = bpy.data.objects.new(name="KeyLight", object_data=light_data)
scene.collection.objects.link(light_object)
light_object.location = (6,-6,6)
light_object.rotation_euler = (math.radians(50),0,math.radians(35))
fill_data = bpy.data.lights.new(name="Fill", type='POINT')
fill_data.energy = 800
fill_obj = bpy.data.objects.new(name="Fill", object_data=fill_data)
scene.collection.objects.link(fill_obj)
fill_obj.location = (-4,2,2)
cam_data = bpy.data.cameras.new("Camera")
cam_obj = bpy.data.objects.new("Camera", cam_data)
scene.collection.objects.link(cam_obj)
scene.camera = cam_obj
cam_obj.location = (10,-10,8)
cam_obj.rotation_euler = (math.radians(55),0,math.radians(45))
cam_data.lens = 45


def make_emissive(name, color=(1,1,1,1), strength=5.0):
    mat = bpy.data.materials.new(name)
    mat.use_nodes = True
    nt = mat.node_tree
    for n in list(nt.nodes):
        nt.nodes.remove(n)
    out = nt.nodes.new("ShaderNodeOutputMaterial")
    emi = nt.nodes.new("ShaderNodeEmission")
    emi.inputs["Color"].default_value = color
    emi.inputs["Strength"].default_value = strength
    nt.links.new(emi.outputs["Emission"], out.inputs["Surface"])
    return mat
def make_principled(name, base=(0.8,0.8,0.8,1), rough=0.5, metallic=0.0):
    mat = bpy.data.materials.new(name)
    mat.use_nodes = True
    bsdf = mat.node_tree.nodes.get("Principled BSDF")
    bsdf.inputs["Base Color"].default_value = base
    bsdf.inputs["Roughness"].default_value = rough
    bsdf.inputs["Metallic"].default_value = metallic
    return mat


bead = make_emissive("Bead", color=(0.95,0.85,0.2,1), strength=15)
thread_mat = make_principled("Thread", base=(0.9,0.3,0.4,1), rough=0.35, metallic=0.0)
pts = []
import random, math
random.seed(123)
for i in range(80):
    x = 6.0*math.cos(i*0.19) + 0.4*random.uniform(-1,1)
    y = 6.0*math.sin(i*0.21) + 0.4*random.uniform(-1,1)
    z = 0.15*math.sin(i*0.11)
    bpy.ops.mesh.primitive_ico_sphere_add(radius=0.08, location=(x,y,z))
    s = bpy.context.active_object; s.data.materials.append(bead)
    pts.append((x,y,z))
cu = bpy.data.curves.new("Thread", 'CURVE')
cu.dimensions = '3D'
sp = cu.splines.new('POLY')
sp.points.add(len(pts)-1)
for i, p in enumerate(pts):
    sp.points[i].co = (p[0], p[1], p[2], 1.0)
cu.bevel_depth = 0.03; cu.use_fill_caps = True
ob = bpy.data.objects.new("ThreadObj", cu)
bpy.context.collection.objects.link(ob)
ob.data.materials.append(thread_mat)
bpy.ops.mesh.primitive_plane_add(size=30, location=(0,0,-0.2))
g = bpy.context.active_object
g.data.materials.append(make_principled("Ground", base=(0.03,0.035,0.04,1), rough=0.95))


blend_path = r"out/blends/stigmergy_markers-20251103T182257Z.blend"
png_path   = r"out/renders/stigmergy_markers-20251103T182257Z.png"
import os
os.makedirs(os.path.dirname(blend_path), exist_ok=True)
os.makedirs(os.path.dirname(png_path), exist_ok=True)
scene.frame_set(1)
scene.render.filepath = png_path
bpy.ops.render.render(write_still=True)
bpy.ops.wm.save_mainfile(filepath=blend_path)
