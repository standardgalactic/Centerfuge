
# AUTOGENERATED by yarncrawler_blender_gen.py
import bpy, math, mathutils, random
bpy.ops.wm.read_factory_settings(use_empty=True)
if not bpy.context.scene: bpy.ops.scene.new(type='NEW')
scene = bpy.context.scene
scene.frame_start = 1
scene.frame_end = 1


engine = "CYCLES"
scene.render.engine = engine
scene.render.resolution_x = 1280
scene.render.resolution_y = 720
scene.render.resolution_percentage = 100
if engine == "CYCLES":
    try:
        bpy.context.scene.cycles.samples = 64
        bpy.context.preferences.addons["cycles"].preferences.compute_device_type = "CUDA"
        bpy.context.scene.cycles.device = "GPU"
    except Exception:
        pass


import math
if scene.world is None:
    scene.world = bpy.data.worlds.new("World")
scene.world.use_nodes = True
wn = scene.world.node_tree
bg = wn.nodes.get("Background")
if bg:
    bg.inputs[0].default_value = (0.015,0.015,0.02,1.0)
    bg.inputs[1].default_value = 1.0
light_data = bpy.data.lights.new(name="KeyLight", type='AREA')
light_data.energy = 3000
light_data.shape = 'RECTANGLE'
light_data.size = 6.0
light_data.size_y = 3.0
light_object = bpy.data.objects.new(name="KeyLight", object_data=light_data)
scene.collection.objects.link(light_object)
light_object.location = (6,-6,6)
light_object.rotation_euler = (math.radians(50),0,math.radians(35))
fill_data = bpy.data.lights.new(name="Fill", type='POINT')
fill_data.energy = 800
fill_obj = bpy.data.objects.new(name="Fill", object_data=fill_data)
scene.collection.objects.link(fill_obj)
fill_obj.location = (-4,2,2)
cam_data = bpy.data.cameras.new("Camera")
cam_obj = bpy.data.objects.new("Camera", cam_data)
scene.collection.objects.link(cam_obj)
scene.camera = cam_obj
cam_obj.location = (10,-10,8)
cam_obj.rotation_euler = (math.radians(55),0,math.radians(45))
cam_data.lens = 45


def make_emissive(name, color=(1,1,1,1), strength=5.0):
    mat = bpy.data.materials.new(name)
    mat.use_nodes = True
    nt = mat.node_tree
    for n in list(nt.nodes):
        nt.nodes.remove(n)
    out = nt.nodes.new("ShaderNodeOutputMaterial")
    emi = nt.nodes.new("ShaderNodeEmission")
    emi.inputs["Color"].default_value = color
    emi.inputs["Strength"].default_value = strength
    nt.links.new(emi.outputs["Emission"], out.inputs["Surface"])
    return mat
def make_principled(name, base=(0.8,0.8,0.8,1), rough=0.5, metallic=0.0):
    mat = bpy.data.materials.new(name)
    mat.use_nodes = True
    bsdf = mat.node_tree.nodes.get("Principled BSDF")
    bsdf.inputs["Base Color"].default_value = base
    bsdf.inputs["Roughness"].default_value = rough
    bsdf.inputs["Metallic"].default_value = metallic
    return mat


import math, random
base = make_principled("TileBase", base=(0.18,0.2,0.25,1), rough=0.6)
hi   = make_principled("TileHi",   base=(0.35,0.75,0.9,1), rough=0.35)
lo   = make_principled("TileLo",   base=(0.08,0.12,0.16,1), rough=0.75)
size = 20
for i in range(-size//2, size//2):
    for j in range(-size//2, size//2):
        z = 0.3*math.sin(0.3*i) * 0.25*math.cos(0.25*j)
        bpy.ops.mesh.primitive_cube_add(size=1, location=(i, j, z-0.55))
        o = bpy.context.active_object
        o.scale = (0.48, 0.48, 0.05 + 0.02*math.sin(0.5*i + 0.3*j))
        if (i*i + j*j) % 7 == 0:
            o.data.materials.append(hi)
        elif (i+j) % 3 == 0:
            o.data.materials.append(base)
        else:
            o.data.materials.append(lo)
scene.camera.location = (12, -18, 12)
scene.camera.rotation_euler = (math.radians(65), 0, math.radians(55))


blend_path = r"out/blends/tiling_grid-20251103T182257Z.blend"
png_path   = r"out/renders/tiling_grid-20251103T182257Z.png"
import os
os.makedirs(os.path.dirname(blend_path), exist_ok=True)
os.makedirs(os.path.dirname(png_path), exist_ok=True)
scene.frame_set(1)
scene.render.filepath = png_path
bpy.ops.render.render(write_still=True)
bpy.ops.wm.save_mainfile(filepath=blend_path)
