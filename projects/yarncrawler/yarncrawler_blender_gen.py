#!/usr/bin/env python3
# (see top-level README for usage)
import argparse
import os
import pathlib
import subprocess
import sys
from textwrap import dedent
from datetime import datetime

SCENE_CHOICES = ["trails", "repair_walkers", "tiling_grid", "stigmergy_markers"]

def parse_resolution(res_str: str):
    try:
        w, h = res_str.lower().split("x")
        return int(w), int(h)
    except Exception:
        raise argparse.ArgumentTypeError("Resolution must look like 1920x1080")

def mkdir(p: pathlib.Path):
    p.mkdir(parents=True, exist_ok=True)
    return p

def write_file(path: pathlib.Path, text: str):
    mkdir(path.parent)
    path.write_text(text, encoding="utf-8")
    return path

def blender_invocation_ok(blender_path: str) -> bool:
    try:
        subprocess.run([blender_path, "--version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
        return True
    except Exception:
        return False

COMMON_HEADER = """
# AUTOGENERATED by yarncrawler_blender_gen.py
import bpy, math, mathutils, random
bpy.ops.wm.read_factory_settings(use_empty=True)
if not bpy.context.scene: bpy.ops.scene.new(type='NEW')
scene = bpy.context.scene
scene.frame_start = 1
scene.frame_end = 1
"""

ENGINE_SETUP = """
engine = "{engine}"
scene.render.engine = engine
scene.render.resolution_x = {res_x}
scene.render.resolution_y = {res_y}
scene.render.resolution_percentage = 100
if engine == "CYCLES":
    try:
        bpy.context.scene.cycles.samples = {samples}
        bpy.context.preferences.addons["cycles"].preferences.compute_device_type = "CUDA"
        bpy.context.scene.cycles.device = "GPU"
    except Exception:
        pass
"""

WORLD_LIGHT_CAMERA = """
import math
if scene.world is None:
    scene.world = bpy.data.worlds.new("World")
scene.world.use_nodes = True
wn = scene.world.node_tree
bg = wn.nodes.get("Background")
if bg:
    bg.inputs[0].default_value = (0.015,0.015,0.02,1.0)
    bg.inputs[1].default_value = 1.0
light_data = bpy.data.lights.new(name="KeyLight", type='AREA')
light_data.energy = 3000
light_data.shape = 'RECTANGLE'
light_data.size = 6.0
light_data.size_y = 3.0
light_object = bpy.data.objects.new(name="KeyLight", object_data=light_data)
scene.collection.objects.link(light_object)
light_object.location = (6,-6,6)
light_object.rotation_euler = (math.radians(50),0,math.radians(35))
fill_data = bpy.data.lights.new(name="Fill", type='POINT')
fill_data.energy = 800
fill_obj = bpy.data.objects.new(name="Fill", object_data=fill_data)
scene.collection.objects.link(fill_obj)
fill_obj.location = (-4,2,2)
cam_data = bpy.data.cameras.new("Camera")
cam_obj = bpy.data.objects.new("Camera", cam_data)
scene.collection.objects.link(cam_obj)
scene.camera = cam_obj
cam_obj.location = (10,-10,8)
cam_obj.rotation_euler = (math.radians(55),0,math.radians(45))
cam_data.lens = 45
"""

MATERIAL_HELPERS = """
def make_emissive(name, color=(1,1,1,1), strength=5.0):
    mat = bpy.data.materials.new(name)
    mat.use_nodes = True
    nt = mat.node_tree
    for n in list(nt.nodes):
        nt.nodes.remove(n)
    out = nt.nodes.new("ShaderNodeOutputMaterial")
    emi = nt.nodes.new("ShaderNodeEmission")
    emi.inputs["Color"].default_value = color
    emi.inputs["Strength"].default_value = strength
    nt.links.new(emi.outputs["Emission"], out.inputs["Surface"])
    return mat
def make_principled(name, base=(0.8,0.8,0.8,1), rough=0.5, metallic=0.0):
    mat = bpy.data.materials.new(name)
    mat.use_nodes = True
    bsdf = mat.node_tree.nodes.get("Principled BSDF")
    bsdf.inputs["Base Color"].default_value = base
    bsdf.inputs["Roughness"].default_value = rough
    bsdf.inputs["Metallic"].default_value = metallic
    return mat
"""

SCENE_TRAILS = """
import random, math
random.seed(42)
trail_mat = make_principled("Trail", base=(0.05,0.8,0.7,1), rough=0.35, metallic=0.05)
node_mat  = make_emissive("Node", color=(0.9,0.15,0.2,1), strength=10.0)
def add_polycurve(points, radius=0.03, mat=None):
    cu = bpy.data.curves.new("TrailCurve", 'CURVE')
    cu.dimensions = '3D'
    spline = cu.splines.new('POLY')
    spline.points.add(len(points)-1)
    for i, p in enumerate(points):
        spline.points[i].co = (*p, 1.0)
    cu.bevel_depth = radius
    cu.use_fill_caps = True
    ob = bpy.data.objects.new("TrailObj", cu)
    bpy.context.collection.objects.link(ob)
    if mat: ob.data.materials.append(mat)
    return ob
for k in range(22):
    p = mathutils.Vector((random.uniform(-4,4), random.uniform(-4,4), random.uniform(-0.2,0.2)))
    pts = [tuple(p)]
    direction = mathutils.Vector((random.uniform(-1,1), random.uniform(-1,1), random.uniform(-0.2,0.2))).normalized()
    length = random.randint(40, 90)
    for i in range(length):
        step = (direction + 0.35*mathutils.Vector((random.uniform(-1,1), random.uniform(-1,1), random.uniform(-0.15,0.15)))).normalized()
        p = p + 0.2*step
        p.z = max(-0.1, min(2.5, p.z))
        pts.append((p.x, p.y, p.z))
    add_polycurve(pts, radius=0.025, mat=trail_mat)
for i in range(36):
    x, y = random.uniform(-4.5,4.5), random.uniform(-4.5,4.5)
    z = random.uniform(0.0, 0.6)
    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.06, enter_editmode=False, location=(x,y,z))
    o = bpy.context.active_object
    o.data.materials.append(node_mat)
bpy.ops.mesh.primitive_plane_add(size=20, location=(0,0,-0.12))
g = bpy.context.active_object
g.data.materials.append(make_principled("Ground", base=(0.04,0.04,0.05,1), rough=0.9, metallic=0.0))
"""

SCENE_REPAIR_WALKERS = """
steel = make_principled("Steel", base=(0.7,0.72,0.75,1), rough=0.2, metallic=0.9)
rubber = make_principled("Rubber", base=(0.02,0.02,0.02,1), rough=0.8, metallic=0.0)
glow   = make_emissive("Beacon", color=(0.9,0.5,0.1,1), strength=20.0)
for i in range(-6, 7):
    for j in range(-6, 7):
        sx = 0.8 + 0.1*((i+j)&1)
        sy = 0.8 + 0.1*(((i*7)+j)&1)
        bpy.ops.mesh.primitive_cube_add(size=1, location=(i*1.05, j*1.05, -0.5))
        t = bpy.context.active_object
        t.scale = (sx, sy, 0.03)
        t.data.materials.append(make_principled("Patch", base=(0.15+0.05*(i&1),0.16,0.17,1), rough=0.7))
def add_walker(pos=(0,0,0)):
    for dx in (-0.6, 0.6):
        bpy.ops.mesh.primitive_cylinder_add(radius=0.06, depth=3.0, location=(pos[0]+dx, pos[1], pos[2]+1.0))
        s = bpy.context.active_object
        s.data.materials.append(steel)
        bpy.ops.mesh.primitive_cylinder_add(radius=0.18, depth=0.1, location=(pos[0]+dx, pos[1], pos[2]-0.5))
        f = bpy.context.active_object
        f.data.materials.append(rubber)
    bpy.ops.mesh.primitive_cube_add(size=1.6, location=(pos[0], pos[1], pos[2]+2.1))
    b = bpy.context.active_object
    b.scale = (1.2, 0.8, 0.6); b.data.materials.append(steel)
    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.15, location=(pos[0], pos[1], pos[2]+3.0))
    be = bpy.context.active_object; be.data.materials.append(glow)
for k in range(6):
    add_walker(pos=(-4.0 + 1.6*k, -2.0 + 0.6*((k&1)-0.5), 0))
scene.camera.location = (8, -12, 9)
scene.camera.rotation_euler = (math.radians(65), 0, math.radians(50))
"""

SCENE_TILING_GRID = """
import math, random
base = make_principled("TileBase", base=(0.18,0.2,0.25,1), rough=0.6)
hi   = make_principled("TileHi",   base=(0.35,0.75,0.9,1), rough=0.35)
lo   = make_principled("TileLo",   base=(0.08,0.12,0.16,1), rough=0.75)
size = 20
for i in range(-size//2, size//2):
    for j in range(-size//2, size//2):
        z = 0.3*math.sin(0.3*i) * 0.25*math.cos(0.25*j)
        bpy.ops.mesh.primitive_cube_add(size=1, location=(i, j, z-0.55))
        o = bpy.context.active_object
        o.scale = (0.48, 0.48, 0.05 + 0.02*math.sin(0.5*i + 0.3*j))
        if (i*i + j*j) % 7 == 0:
            o.data.materials.append(hi)
        elif (i+j) % 3 == 0:
            o.data.materials.append(base)
        else:
            o.data.materials.append(lo)
scene.camera.location = (12, -18, 12)
scene.camera.rotation_euler = (math.radians(65), 0, math.radians(55))
"""

SCENE_STIGMERGY = """
bead = make_emissive("Bead", color=(0.95,0.85,0.2,1), strength=15)
thread_mat = make_principled("Thread", base=(0.9,0.3,0.4,1), rough=0.35, metallic=0.0)
pts = []
import random, math
random.seed(123)
for i in range(80):
    x = 6.0*math.cos(i*0.19) + 0.4*random.uniform(-1,1)
    y = 6.0*math.sin(i*0.21) + 0.4*random.uniform(-1,1)
    z = 0.15*math.sin(i*0.11)
    bpy.ops.mesh.primitive_ico_sphere_add(radius=0.08, location=(x,y,z))
    s = bpy.context.active_object; s.data.materials.append(bead)
    pts.append((x,y,z))
cu = bpy.data.curves.new("Thread", 'CURVE')
cu.dimensions = '3D'
sp = cu.splines.new('POLY')
sp.points.add(len(pts)-1)
for i, p in enumerate(pts):
    sp.points[i].co = (p[0], p[1], p[2], 1.0)
cu.bevel_depth = 0.03; cu.use_fill_caps = True
ob = bpy.data.objects.new("ThreadObj", cu)
bpy.context.collection.objects.link(ob)
ob.data.materials.append(thread_mat)
bpy.ops.mesh.primitive_plane_add(size=30, location=(0,0,-0.2))
g = bpy.context.active_object
g.data.materials.append(make_principled("Ground", base=(0.03,0.035,0.04,1), rough=0.95))
"""

FOOTER_SAVE_RENDER = """
blend_path = r"{blend_path}"
png_path   = r"{png_path}"
import os
os.makedirs(os.path.dirname(blend_path), exist_ok=True)
os.makedirs(os.path.dirname(png_path), exist_ok=True)
scene.frame_set(1)
scene.render.filepath = png_path
bpy.ops.render.render(write_still=True)
bpy.ops.wm.save_mainfile(filepath=blend_path)
"""

def build_scene_script(scene_name: str, engine: str, res_xy, samples: int, blend_path: str, png_path: str) -> str:
    base = [COMMON_HEADER,
            ENGINE_SETUP.format(engine=engine, res_x=res_xy[0], res_y=res_xy[1], samples=samples),
            WORLD_LIGHT_CAMERA,
            MATERIAL_HELPERS]
    if scene_name == "trails":
        base.append(SCENE_TRAILS)
    elif scene_name == "repair_walkers":
        base.append(SCENE_REPAIR_WALKERS)
    elif scene_name == "tiling_grid":
        base.append(SCENE_TILING_GRID)
    elif scene_name == "stigmergy_markers":
        base.append(SCENE_STIGMERGY)
    else:
        raise ValueError(f"Unknown scene {scene_name}")
    base.append(FOOTER_SAVE_RENDER.format(blend_path=blend_path, png_path=png_path))
    return "\n".join(base)

def main():
    ap = argparse.ArgumentParser(description="Generate Yarncrawler Blender scripts and optionally render stills (no animations).")
    ap.add_argument("--outdir", required=True, help="Output directory root (scripts/, blends/, renders/ will be created)")
    ap.add_argument("--scenes", default="all", help="Comma-separated subset of scenes: trails,repair_walkers,tiling_grid,stigmergy_markers OR 'all'")
    ap.add_argument("--render", action="store_true", help="If set, invoke Blender headless to render stills and save .blend")
    ap.add_argument("--blender", default="blender", help="Path to Blender executable (default: 'blender' on PATH)")
    ap.add_argument("--engine", default="CYCLES", choices=["CYCLES","BLENDER_EEVEE"], help="Render engine")
    ap.add_argument("--samples", type=int, default=64, help="Samples for Cycles (ignored by Eevee)")
    ap.add_argument("--res", type=parse_resolution, default="1280x720", help="Resolution WxH, e.g., 1920x1080")
    ap.add_argument("--tag", default="", help="Optional tag to include in filenames")
    args = ap.parse_args()
    out_root = pathlib.Path(args.outdir)
    scripts_dir = out_root / "scripts"
    blends_dir  = out_root / "blends"
    renders_dir = out_root / "renders"
    for d in (scripts_dir, blends_dir, renders_dir): d.mkdir(parents=True, exist_ok=True)
    timestamp = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
    tag = f"-{args.tag}" if args.tag else ""
    if args.scenes.strip().lower() == "all":
        scene_list = SCENE_CHOICES
    else:
        scene_list = [s.strip() for s in args.scenes.split(",") if s.strip()]
    generated = []
    for scene in scene_list:
        base_name = f"{scene}{tag}-{timestamp}"
        script_path = scripts_dir / f"{base_name}.py"
        blend_path  = blends_dir  / f"{base_name}.blend"
        png_path    = renders_dir / f"{base_name}.png"
        text = build_scene_script(scene, args.engine, args.res, args.samples, str(blend_path), str(png_path))
        script_path.write_text(text, encoding="utf-8")
        generated.append((scene, script_path, blend_path, png_path))
        print(f"[OK] Wrote {script_path}")
    if args.render:
        if not blender_invocation_ok(args.blender):
            print(f"[ERROR] Could not invoke Blender at '{args.blender}'. Skipping renders.", file=sys.stderr)
            sys.exit(2)
        for (scene, script_path, blend_path, png_path) in generated:
            cmd = [args.blender, "-b", "-noaudio", "--python", str(script_path)]
            print(f"[RUN] {' '.join(cmd)}")
            try:
                subprocess.run(cmd, check=True)
                print(f"[DONE] Rendered {png_path} and saved {blend_path}")
            except subprocess.CalledProcessError as e:
                print(f"[FAIL] Blender run failed for {scene}: {e}", file=sys.stderr)

if __name__ == "__main__":
    main()
