<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>RSVP Blender Visualizations</title>
<style>
body{background:#0b0b0f;color:#e0e0e0;font-family:system-ui,-apple-system,"Segoe UI",sans-serif;margin:2em}
h1{font-weight:600;font-size:1.8em;margin-bottom:0.3em}
button#refresh{background:#222;color:#9feaff;border:1px solid #333;border-radius:6px;padding:0.4em 1em;font-size:0.9em;cursor:pointer;margin-left:0.5em}
button#refresh:hover{background:#2a2a2a}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(340px,1fr));gap:1.4em}
.card{background:#16161c;border-radius:8px;padding:1em;box-shadow:0 0 12px rgba(0,0,0,.6);text-align:center;transition:transform .2s ease}
.card:hover{transform:scale(1.02)}
.card img,.card video{width:100%;border-radius:4px;background:#000;max-height:280px;object-fit:cover;cursor:pointer}
.card h2{font-size:1.1em;margin-top:.5em;color:#9feaff}
.meta{font-size:.85em;color:#aaa;margin-top:.3em;line-height:1.4em}
footer{margin-top:2em;font-size:.9em;color:#666;text-align:center}
#updated{color:#888;font-size:.85em;margin-left:.3em}

/* Lightbox */
#lightbox{position:fixed;inset:0;background:rgba(0,0,0,.92);display:none;justify-content:center;align-items:center;z-index:1000}
#lightbox video,#lightbox img{max-width:90%;max-height:90%;border:2px solid #444;border-radius:6px;background:#000}
#lightboxClose{position:fixed;top:20px;right:25px;color:#ccc;font-size:2em;cursor:pointer;z-index:1001;font-weight:bold}
#lightboxClose:hover{color:#fff}
.navArrow{position:fixed;top:50%;transform:translateY(-50%);font-size:2.5em;color:#ccc;cursor:pointer;user-select:none;z-index:1001;font-weight:bold;transition:color .2s}
.navArrow:hover{color:#fff}
#prevArrow{left:25px}
#nextArrow{right:25px}
</style>
</head>
<body>
<h1>
  RSVP Blender Visualizations
  <button id="refresh">Check for Updates</button>
  <span id="updated"></span>
</h1>
<div id="grid" class="grid"></div>
<footer>Generated by <code>rsvp_blender_gen.py</code> — manifest-first static viewer</footer>

<!-- Lightbox -->
<div id="lightbox">
  <span id="lightboxClose">&times;</span>
  <span id="prevArrow" class="navArrow">&#10094;</span>
  <span id="nextArrow" class="navArrow">&#10095;</span>
  <img id="lightboxImg" style="display:none">
  <video id="lightboxVid" style="display:none" controls autoplay loop></video>
</div>

<script>
let manifestCache = [];
let currentIndex = -1;

// Turn any absolute path into a path relative to /out/ (so the browser can load it)
function toOutRelative(p) {
  if (!p) return null;
  // Support Windows-style backslashes too
  const norm = p.replace(/\\/g, '/');
  const i = norm.lastIndexOf('/out/');
  if (i >= 0) return norm.slice(i + 5); // strip up to "/out/"
  // If path already looks relative, keep it
  if (!norm.startsWith('/') && !norm.match(/^[a-zA-Z]:\//)) return norm;
  // Fallback: derive from known subfolders
  const name = norm.split('/').pop();
  if (name.endsWith('.png') || name.endsWith('.jpg') || name.endsWith('.jpeg')) return 'renders/' + name;
  if (name.endsWith('.mp4') || name.endsWith('.webm')) return 'videos/' + name;
  if (name.endsWith('.blend')) return 'blends/' + name;
  return name; // best-effort
}

async function loadManifest() {
  try {
    const r = await fetch('manifest.json?' + Date.now());
    const j = await r.json();
    const items = (j.generated || []).map(it => ({
      name: it.name,
      animated: !!it.animated,
      // normalize to relative URLs under out/
      render: toOutRelative(it.render),
      video: toOutRelative(it.video),
      blend: toOutRelative(it.blend)
    }));
    // Remove duplicates (e.g., items that have both render and video entries could be separate in some manifests)
    const byName = new Map();
    for (const it of items) {
      if (!byName.has(it.name)) byName.set(it.name, it);
      else {
        const prev = byName.get(it.name);
        byName.set(it.name, {
          ...prev,
          render: prev.render || it.render,
          video: prev.video || it.video,
          animated: prev.animated || it.animated,
          blend: prev.blend || it.blend
        });
      }
    }
    return Array.from(byName.values());
  } catch (e) {
    console.warn('manifest.json not found or unreadable:', e);
    return [];
  }
}

function addOnErrorHide(el) {
  el.addEventListener('error', () => {
    // Hide the element if the file isn't present to avoid broken thumbnails
    el.style.display = 'none';
  });
}

async function render() {
  const grid = document.getElementById('grid');
  grid.innerHTML = '';
  manifestCache = await loadManifest();
  if (!manifestCache.length) {
    grid.innerHTML = '<p>No manifest found or empty. Make sure <code>manifest.json</code> is in <code>out/</code> and paths point to <code>renders/</code> or <code>videos/</code>.</p>';
    return;
  }
  document.getElementById('updated').textContent = '(last loaded ' + new Date().toLocaleTimeString() + ')';

  for (const [i, item] of manifestCache.entries()) {
    const card = document.createElement('div');
    card.className = 'card';

    const title = document.createElement('h2');
    title.textContent = item.name.replace(/_/g, ' ');
    card.appendChild(title);

    let mediaEl = null;
    if (item.video && item.animated) {
      const vid = document.createElement('video');
      vid.src = item.video;
      vid.loop = true;
      vid.muted = true;
      vid.autoplay = false;
      addOnErrorHide(vid);
      mediaEl = vid;
    } else if (item.render) {
      const img = document.createElement('img');
      img.src = item.render;
      img.loading = 'lazy';
      addOnErrorHide(img);
      mediaEl = img;
    } else {
      // Try a best-effort default guess (image)
      const img = document.createElement('img');
      img.src = 'renders/' + item.name + '.png';
      img.loading = 'lazy';
      addOnErrorHide(img);
      mediaEl = img;
    }

    if (mediaEl) {
      mediaEl.addEventListener('click', () => openLightbox(i));
      card.appendChild(mediaEl);
    }

    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.innerHTML = `Animated: ${item.animated ? '✅ Yes' : '❌ No'}<br>
                      Render: ${item.render || '—'}<br>
                      Video: ${item.video || '—'}`;
    card.appendChild(meta);

    grid.appendChild(card);
  }
}

// Lightbox
function openLightbox(index) {
  currentIndex = index;
  const item = manifestCache[index];
  const box = document.getElementById('lightbox');
  const img = document.getElementById('lightboxImg');
  const vid = document.getElementById('lightboxVid');

  if (item.video && item.animated) {
    img.style.display = 'none';
    vid.style.display = 'block';
    vid.src = item.video;
  } else {
    vid.style.display = 'none';
    img.style.display = 'block';
    img.src = item.render || ('renders/' + item.name + '.png');
  }
  box.style.display = 'flex';
}
function closeLightbox() {
  document.getElementById('lightbox').style.display = 'none';
  const vid = document.getElementById('lightboxVid');
  vid.pause();
  currentIndex = -1;
}
function nextMedia(step) {
  if (currentIndex < 0) return;
  const newIndex = (currentIndex + step + manifestCache.length) % manifestCache.length;
  openLightbox(newIndex);
}

document.getElementById('lightboxClose').addEventListener('click', closeLightbox);
document.getElementById('prevArrow').addEventListener('click', () => nextMedia(-1));
document.getElementById('nextArrow').addEventListener('click', () => nextMedia(1));
document.getElementById('lightbox').addEventListener('click', e => { if (e.target.id === 'lightbox') closeLightbox(); });
document.getElementById('refresh').addEventListener('click', render);
document.addEventListener('keydown', e => {
  if (currentIndex >= 0) {
    if (e.key === 'Escape') closeLightbox();
    if (e.key === 'ArrowRight') nextMedia(1);
    if (e.key === 'ArrowLeft') nextMedia(-1);
  }
});

render();
</script>
</body>
</html>
